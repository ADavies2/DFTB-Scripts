#!/bin/bash

# Declare an associative array for the Hubbard derivatives of each element for the 3ob parameters
declare -A HUBBARD
HUBBARD[Br]=-0.0573
HUBBARD[C]=-0.1492
HUBBBARD[Ca]=-0.034
HUBBARD[Cl]=-0.0697
HUBBARD[F]=-0.1623
HUBBARD[H]=-0.1857
HUBBARD[I]=-0.0433
HUBBARD[K]=-0.0339
HUBBARD[Mg]=-0.02
HUBBARD[N]=-0.1535
HUBBARD[Na]=-0.0454
HUBBARD[O]=-0.1575
HUBBARD[P]=-0.14
HUBBARD[S]=-0.11
HUBBARD[Zn]=-0.03

# Declare an associative array for the max angular momentum orbitals for each element for the 3ob parameters
declare -A MOMENTUM
MOMENTUM[Br]=d
MOMENTUM[C]=p
MOMENTUM[Ca]=p
MOMENTUM[Cl]=d
MOMENTUM[F]=p
MOMENTUM[H]=s
MOMENTUM[I]=d
MOMENTUM[K]=p
MOMENTUM[Mg]=p
MOMENTUM[N]=p
MOMENTUM[Na]=p
MOMENTUM[O]=p
MOMENTUM[P]=d
MOMENTUM[S]=d
MOMENTUM[Zn]=d

# Declare an associative array for the atomic/gaseous phase energy for each element (calculated so far)
declare -A ATOMIC_ENERGY
ATOMIC_ENERGY[C]=-38.055
ATOMIC_ENERGY[H]=-6.4926
ATOMIC_ENERGY[N]=-57.2033
ATOMIC_ENERGY[O]=-83.9795
ATOMIC_ENERGY[S]=-62.3719
ATOMIC_ENERGY[Br]=-79.5349
ATOMIC_ENERGY[F]=-115.2462
ATOMIC_ENERGY[Cl]=-84.1056
ATOMIC_ENERGY[K]=-2.3186

# Declare an associative array for the reference state energy for each element (calculated so far)
declare -A REFERENCE_ENERGY
REFERENCE_ENERGY[C]=-44.1197
REFERENCE_ENERGY[H]=-9.1083
REFERENCE_ENERGY[N]=-65.4249
REFERENCE_ENERGY[O]=-87.7172
REFERENCE_ENERGY[S]=-65.7086
REFERENCE_ENERGY[Br]=-81.167
REFERENCE_ENERGY[F]=-117.3936
REFERENCE_ENERGY[Cl]=-86.2041
REFERENCE_ENERGY[K]=-3.4933

scc_dftb_in () {
# 1 = $GEO
# 2 = $TOL
# 3 = $RESTART
# 4 = myHUBBARD
# 5 = myMOMENTUM
  if [[ $1 == *"gen"* ]]; then
    cat > dftb_in.hsd <<!
Geometry = GenFormat {
  <<< "$1"
}
!
  else
    cat > dftb_in.hsd <<!
Geometry = VASPFormat {
  <<< "$1"
}
!
  fi
  cat >> dftb_in.hsd <<!
Driver = ConjugateGradient {
  MovedAtoms = 1:-1
  MaxSteps = 100000
  LatticeOpt = Yes
  AppendGeometries = No
!
  if [ $2 == '1e-5' ]; then
    printf "  MaxForceComponent = 1e-4\n" >> dftb_in.hsd
    printf "  OutputPrefix = 1e-4-Out }\n" >> dftb_in.hsd
  else
    printf "  MaxForceComponent = $2\n" >> dftb_in.hsd
    printf "  OutputPrefix = $2-Out }\n" >> dftb_in.hsd
  fi
  cat >> dftb_in.hsd <<!
Hamiltonian = DFTB {
SCC = Yes
SCCTolerance = $2
!
  if [[ $3 == "yes" ]]; then
    printf "ReadInitialCharges = Yes\n" >> dftb_in.hsd
  else
    printf "ReadInitialCharges = No\n" >> dftb_in.hsd
  fi
  cat >> dftb_in.hsd <<!
MaxSCCIterations = 5000
ThirdOrderFull = Yes
Dispersion = LennardJones {
  Parameters = UFFParameters{} }
HCorrection = Damping {
  Exponent = 4.05 }
HubbardDerivs {
!
  hubbard=$4[@]
  sccHUBBARD=("${!hubbard}")
  printf "%s\n" "${sccHUBBARD[@]} }" >> dftb_in.hsd
  cat >> dftb_in.hsd <<!
SlaterKosterFiles = Type2FileNames {
  Prefix = "/project/designlab/Shared/Codes/dftb+sk/3ob-3-1/"
  Separator = "-"
  Suffix = ".skf" }
KPointsAndWeights = SupercellFolding {
  4 0 0
  0 4 0
  0 0 4
  0.5 0.5 0.5 }
MaxAngularMomentum {
!
  momentum=$5[@]
  sccMOMENTUM=("${!momentum}")
  printf "%s\n" "${sccMOMENTUM[@]} }" >> dftb_in.hsd
  cat >> dftb_in.hsd <<!
Filling = Fermi {
  Temperature [Kelvin] = 0 } }
!
  if [ $2 == '1e-5' ]; then
    printf "%s\n" "Analysis = {" >> dftb_in.hsd
    printf "%s\n" "  MullikenAnalysis = Yes" >> dftb_in.hsd
    printf "%s\n" "  WriteEigenvectors = Yes" >> dftb_in.hsd
    printf "%s\n" "  AtomResolvedEnergies = Yes" >> dftb_in.hsd
    printf "%s\n" "  CalculateForces = Yes }" >> dftb_in.hsd
  else
    printf "%s\n" "Analysis = {" >> dftb_in.hsd
    printf "%s\n" "  MullikenAnalysis = Yes }" >> dftb_in.hsd
  fi
  cat >> dftb_in.hsd <<!
Parallel = {
  Groups = 1
  UseOmpThreads = Yes }
ParserOptions {
  ParserVersion = 12 }
!
  if [ $2 == '1e-5' ]; then
    printf "%s\n" "Options {" >> dftb_in.hsd
    printf "%s\n" "WriteDetailedXML = Yes" >> dftb_in.hsd
    printf "%s\n" "WriteChargesAsText = Yes }" >> dftb_in.hsd
  fi 
}

gen_submit () {
# 1= Task
# 2 = CPUS
# 3 = JOBNAME
# 4 = Partition
        NODE=1
        MEM=30gb
        TIME=72:00:00
        SCRIPT_NAME=submit_$3
        PROC=$((NODE * $1))

        cat > $SCRIPT_NAME<<!
#!/bin/bash
#SBATCH --nodes=$NODE
#SBATCH --ntasks-per-node=$1
#SBATCH --cpus-per-task=$2
#SBATCH --account=designlab
#SBATCH --time=$TIME
#SBATCH --job-name=$3
#SBATCH --output=$3.out
#SBATCH --partition=$4
#SBATCH --mem=$MEM
cd \$SLURM_SUBMIT_DIR
export OMP_NUM_THREADS=$2
module load arcc/1.0 dftb/22.2
mpirun -n $PROC dftb+ > $3.log
!
}

calculate_energies () {
# $1 = $GEN
# $2 = $cof
  printf "$1\n$2-POSCAR" | gen-to-POSCAR.py
  GEO="$2-POSCAR"
  ATOM_TYPES=($(sed -n 6p $GEO))
  N_TYPES=($(sed -n 7p $GEO))
  N_ATOMS=0
  for i in ${N_TYPES[@]}; do
    let N_ATOMS+=$i
    done

  E_atom=0
  E_ref=0
  count=0
  for element in ${ATOM_TYPES[@]}; do
    E_atom=$(echo $E_atom+${ATOMIC_ENERGY[$element]}*${N_TYPES[$count]} | bc)
    E_ref=$(echo $E_ref+${REFERENCE_ENERGY[$element]}*${N_TYPES[$count]} | bc)
    ((count++))
  done

  DETAILED=($(grep "Total energy" detailed.out))
  TOTAL_ENERGY=${DETAILED[4]}

  COHESIVE=$(echo "scale=3; ($E_atom - $TOTAL_ENERGY) / $N_ATOMS" | bc)
  ENTHALPY=$(echo "scale=3; ($TOTAL_ENERGY - $E_ref) / $N_ATOMS" | bc)

  cat > Energies.dat <<!
E(COH) $COHESIVE eV
H(f) $ENTHALPY eV
!
}
zeo () {
# $1 = $COFNAME
  # Pore diameters
  ~/zeo++-0.3/network -ha -res $1.res $1.cif > OUTPUT
  # Surface area
  ~/zeo++-0.3/network -ha -sa 1.8 1.8 10000 $1.sa $1.cif >> OUTPUT
  # Accessible volume
  ~/zeo++-0.3/network -ha -vol 1.8 1.8 10000 $1.vol $1.cif >> OUTPUT
}

scc1 () {
# $1 = $PARTITION
# $2 = $JOBNAME
# $3 = $STALL
# $4 = $TASK
# $5 = $TOL
# $6 = $COF
  if [[ $3 != 'none' ]]; then
    if (($4 == 16)); then
      TASK=8
      gen_submit $TASK 1 $2 $1
    elif (($4 == 8)); then
      TASK=4
      gen_submit $TASK 1 $2 $1
    fi
  else
    TASK=16
    gen_submit $TASK 1 $2 $1
  fi
  submit=($(sbatch submit_$2))
  JOBID=(${submit[3]})
  echo "$JOBID submitted"
  while :
  do
    stat=($(squeue -n $2))
    jobstat=(${stat[12]})
    if [ "$jobstat" == "PD" ]; then
        echo "$2 is pending..."
        sleep 5s
    else
        log_size=($(ls -l "$2.log"))
        size=(${log_size[4]})
        sleep 120s
        log_size2=($(ls -l "$2.log"))
        size2=(${log_size2[4]})
        if [[ $size2 > $size ]]; then
          echo "$2 is running..."
        elif [[ $size2 == $size ]]; then
          sleep 15s
          if grep -q "Geometry converged" detailed.out && grep -q "Geometry converged" $2.log; then
            if [[ $5 == '1e-5' ]]; then
              if [ ! -d "1e-4-Outputs" ]; then
                mkdir '1e-4-Outputs'
              fi
              densities=($(printf "$6\ngen\n1e-4-Out.gen" | atomdensities.py))
              calculate_energies '1e-4-Out.gen' $6
              mv detailed* $2.log 1e-4-Out.* charges.* eigenvec.bin submit_$2 Energies.dat *.densities 1e-4-Outputs/
              rm *.gen *.xyz $6*.out band.out
              RESULT='success1'
              STALL='none'
              break
            elif [[ $5 == '1e-1' || $5 = '1e-2' || $5 = '1e-3' ]]; then
              if [ ! -d "$5-Outputs" ]; then
                mkdir $5-Outputs
              fi
              cp $5-Out.gen charges.bin $5-Outputs/
              mv detailed.out $2.log $5-Out.xyz submit_$2 $5-Outputs/
              sed -i 's/.*Geometry.*/Geometry = GenFormat {/g' dftb_in.hsd
              sed -i "s/.*<<<.*/  <<< ""$5-Out.gen""/g" dftb_in.hsd
              sed -i 's/.*ReadInitialCharges.*/ReadInitialCharges = Yes/g' dftb_in.hsd           
              if [ $5 == '1e-1' ]; then
                TOL='1e-2'
                sed -i "s/.*MaxForceComponent.*/  MaxForceComponent = $TOL/g" dftb_in.hsd
                sed -i "s/.*OutputPrefix.*/  OutputPrefix = "$TOL-Out" }/g" dftb_in.hsd
              elif [ $5 == '1e-2' ]; then
                TOL='1e-3'
                sed -i "s/.*MaxForceComponent.*/  MaxForceComponent = $TOL/g" dftb_in.hsd
                sed -i "s/.*OutputPrefix.*/  OutputPrefix = "$TOL-Out" }/g" dftb_in.hsd
              elif [ $5 == '1e-3' ]; then
                TOL='1e-5'
                sed -i 's/.*MaxForceComponent.*/  MaxForceComponent = 1e-4/g' dftb_in.hsd
                sed -i 's/.*OutputPrefix.*/  OutputPrefix = "1e-4-Out" }/g' dftb_in.hsd
                sed -i '/.*Analysis.*/d' dftb_in.hsd
                cat >> dftb_in.hsd <<!
Analysis = {
  MullikenAnalysis = Yes
  AtomResolvedEnergies = Yes
  WriteEigenvectors = Yes
  CalculateForces = Yes }
Options {
  WriteChargesAsText = Yes
  WriteDetailedXML = Yes }
!
              fi
              sed -i "s/.*SCCTolerance.*/SCCTolerance = $TOL/g" dftb_in.hsd
              echo "$2 has completed."
              JOBNAME="$6-scc-$TOL"
              RESULT='success2'
              STALL='none'
              break
            fi
          elif grep -q "SCC is NOT converged" $2.log; then
            echo "$2 did NOT converge. User trouble-shoot required to check atoms."
            exit
          elif grep -q "ERROR!" $2.log; then
            echo "DFTB+ Error. User trouble-shoot required."
            exit
          else
            sleep 180s
            log_size3=($(ls -l "$2.log"))
            size3=(${log_size3[4]})
            if [[ $size3 == $size2 ]]; then
              echo "$JOBID has stalled. Restarting..."
              qdel $JOBID
              sleep 5s
              STALL='scc1'
              RESULT='none'
              if [[ $5 == '1e-5' ]]; then
                sed -i "s/.*<<<.*/   <<< '1e-4-Out.gen'/g" dftb_in.hsd
              else
                sed -i "s/.*<<<.*/   <<< '$5-Out.gen'/g" dftb_in.hsd
              fi
              break
            fi 
          fi
        fi
      fi
  done
}

module load gcc/11.2.0 python/3.10.8

# The instruction file is passed as an arguement when the job is submitted
INSTRUCT=$1

# Read the input file for the COF name, starting tolerance, restart calculation, input structure file, and partition
COF=($(sed -n 2p $INSTRUCT))
TOL=($(sed -n 4p $INSTRUCT))
GEO=($(sed -n 6p $INSTRUCT))
RESTART=($(sed -n 8p $INSTRUCT))
PARTITION=($(sed -n 10p $INSTRUCT))
SCAN=($(sed -n 12p $INSTRUCT))

STALL='none'
TASK=16
JOBNAME="$COF-scc-$TOL"

# Read input geometry file to get atom types and number of atoms  
if [[ $GEO == *"gen"* ]]; then
  ATOM_TYPES=($(sed -n 2p $GEO))
elif [[ $SCAN == 'yes' ]]; then
  ATOM_TYPES=($(sed -n 1p $GEO))
else
  ATOM_TYPES=($(sed -n 6p $GEO))
fi

# Read atom types into a function for angular momentum and Hubbard derivative values
declare -A myHUBBARD
declare -A myMOMENTUM
nl=$'\n'
for element in ${ATOM_TYPES[@]}; do
  myHUBBARD[$element]="$element = ${HUBBARD[$element]}"
  myMOMENTUM[$element]="$element = ${MOMENTUM[$element]}"
done

# Write dftb_in.hsd for the first calculation
scc_dftb_in $GEO $TOL $RESTART myHUBBARD myMOMENTUM

# LOOP 1 (LIGHTBLUE) RESULTS, SUBMITTING LOOP 2 (LIGHTGREEN) CALCULATIONS
# submit the first calculation
scc1 $PARTITION $JOBNAME $STALL $TASK $TOL $COF #16 tasks
if [[ $STALL == 'scc1' ]]; then 
  scc1 $PARTITION $JOBNAME $STALL $TASK $TOL $COF #8 tasks
  if [[ $STALL == 'scc1' ]]; then 
    scc1 $PARTITION $JOBNAME $STALL $TASK $TOL $COF #4 tasks
      if [ $RESULT == 'success1' ]; then
        echo "$COF is fully relaxed!"
        exit
      elif [ $RESULT == 'success2' ]; then
        scc1 $PARTITION $JOBNAME $STALL $TASK $TOL $COF $RESULT
      fi
  elif [ $RESULT == 'success1' ]; then
    echo "$COF is fully relaxed!"
    exit
  elif [ $RESULT == 'success2' ]; then
    scc1 $PARTITION $JOBNAME $STALL $TASK $TOL $COF $RESULT
  fi
elif [ $RESULT == 'success1' ]; then
  echo "$COF is fully relaxed!"
  exit
elif [ $RESULT == 'success2' ]; then
  scc1 $PARTITION $JOBNAME $STALL $TASK $TOL $COF $RESULT
fi

# LOOP 2 (LIGHTBLUE) RESULTS, SUBMITTING LOOP 2 (LIGHTGREEN) CALCULATIONS
# submit the first calculation
if [[ $STALL == 'scc1' ]]; then 
  scc1 $PARTITION $JOBNAME $STALL $TASK $TOL $COF #8 tasks
  if [[ $STALL == 'scc1' ]]; then 
    scc1 $PARTITION $JOBNAME $STALL $TASK $TOL $COF #4 tasks
      if [ $RESULT == 'success1' ]; then
        echo "$COF is fully relaxed!"
        exit
      elif [ $RESULT == 'success2' ]; then
        scc1 $PARTITION $JOBNAME $STALL $TASK $TOL $COF $RESULT
      fi
  elif [ $RESULT == 'success1' ]; then
    echo "$COF is fully relaxed!"
    exit
  elif [ $RESULT == 'success2' ]; then
    scc1 $PARTITION $JOBNAME $STALL $TASK $TOL $COF $RESULT
  fi
elif [ $RESULT == 'success1' ]; then
  echo "$COF is fully relaxed!"
  exit
elif [ $RESULT == 'success2' ]; then
  scc1 $PARTITION $JOBNAME $STALL $TASK $TOL $COF $RESULT
fi

# LOOP 3 (LIGHTBLUE) RESULTS, SUBMITTING LOOP 2 (LIGHTGREEN) CALCULATIONS
# submit the first calculation
if [[ $STALL == 'scc1' ]]; then 
  scc1 $PARTITION $JOBNAME $STALL $TASK $TOL $COF #8 tasks
  if [[ $STALL == 'scc1' ]]; then 
    scc1 $PARTITION $JOBNAME $STALL $TASK $TOL $COF #4 tasks
      if [ $RESULT == 'success1' ]; then
        echo "$COF is fully relaxed!"
        exit
      elif [ $RESULT == 'success2' ]; then
        scc1 $PARTITION $JOBNAME $STALL $TASK $TOL $COF $RESULT
      fi
  elif [ $RESULT == 'success1' ]; then
    echo "$COF is fully relaxed!"
    exit
  elif [ $RESULT == 'success2' ]; then
    scc1 $PARTITION $JOBNAME $STALL $TASK $TOL $COF $RESULT
  fi
elif [ $RESULT == 'success1' ]; then
  echo "$COF is fully relaxed!"
  exit
elif [ $RESULT == 'success2' ]; then
  scc1 $PARTITION $JOBNAME $STALL $TASK $TOL $COF $RESULT
fi

# LOOP 4 (LIGHTBLUE) RESULTS, SUBMITTING LOOP 2 (LIGHTGREEN) CALCULATIONS
# submit the first calculation
if [[ $STALL == 'scc1' ]]; then 
  scc1 $PARTITION $JOBNAME $STALL $TASK $TOL $COF #8 tasks
  if [[ $STALL == 'scc1' ]]; then 
    scc1 $PARTITION $JOBNAME $STALL $TASK $TOL $COF #4 tasks
      if [ $RESULT == 'success1' ]; then
        echo "$COF is fully relaxed!"
        exit
      elif [ $RESULT == 'success2' ]; then
        scc1 $PARTITION $JOBNAME $STALL $TASK $TOL $COF $RESULT
      fi
  elif [ $RESULT == 'success1' ]; then
    echo "$COF is fully relaxed!"
    exit
  elif [ $RESULT == 'success2' ]; then
    scc1 $PARTITION $JOBNAME $STALL $TASK $TOL $COF $RESULT
  fi
elif [ $RESULT == 'success1' ]; then
  echo "$COF is fully relaxed!"
  exit
elif [ $RESULT == 'success2' ]; then
  scc1 $PARTITION $JOBNAME $STALL $TASK $TOL $COF $RESULT
fi